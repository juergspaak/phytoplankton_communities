"""@author: J.W.Spaak

create different fluctuating incoming light functions

# examples
import matplotlib.pyplot as plt
period = 10 # period length
# creates fucntion I_in(t)
I_in = fluc_continuous(fluc_fun = linear(midpoint = 0.7)) 
time = np.linspace(0,period, period+1)
I_int = I_in(time) # creates array with shape (period+1, 101)

# visualize incoming light over time
plt.figure()
plt.plot(np.linspace(400,700,101), I_int.T)

# case where we switch betwenn 2 I_in functions
I_in = fluc_nconst()
I_int = I_in(time)
plt.figure()
plt.plot(np.linspace(400,700, 101), I_int.T)

# case where we switch betwenn 4 I_in functions
I_ins = np.array([mf.I_in_def(40/300, 450,50), 
                      mf.I_in_def(40/300, 650,50),
                      mf.I_in_def(60/300, 550, 50),
                      mf.I_in_def(70/300, 550, 0)])

I_in = fluc_nconst(I_ins = I_ins)
I_int = I_in(time)
plt.figure()
plt.plot(np.linspace(400,700, 101), I_int.T)
"""


# additional allow sinus and saw fluctuations

import numpy as np

import sys
sys.path.append("../3_different_pigments")
from load_pigments import lambs, dlam
import multispecies_functions as mf

from scipy.integrate import simps

def I_in_def(lux, loc = 550, sigma = 50):
    """ returns a incoming light function, a gaussian kernel"""
    if sigma == 0:
        return np.full(lambs.shape, lux, dtype = "float")/300
    else:
        lambs_int = lambs.reshape(-1,1)
        prelim = np.exp(-(lambs_int-loc)**2/(2*sigma**2))
        return (lux*prelim/simps(prelim, dx = dlam, axis = 0)).T

###############################################################################
# functions to switch between I_ins
        
def sinus(t):
    # sinus shaped in t, t must be in [0,1]
    return (np.array([np.cos(2*np.pi*t)+1, 1-np.cos(2*np.pi*t)])/2).T

def linear(midpoint = 0.5):
    # saw shaped in t, t must be in [0,1], midpoint is edge of the saw
    return lambda t: ((t<midpoint)*np.array([1-t/midpoint, t/midpoint])+\
            (t>midpoint)*np.array([t/(1-midpoint)-midpoint/(1-midpoint),
             1/(1-midpoint)-t/(1-midpoint)])).T
            
###############################################################################
# funtctions that return a callable I_in(t)

def fluc_continuous(w_loc = [400, 700], w_lux = [30/300, 50/300],
                p_loc = 10, p_lux = None, fluc_fun=sinus, sigma = 50):
    """returns I_in(t), that continously fluctuates over the spectrum
    
    I_in(t) is a function generated by mf.I_in_def
    
    w_loc: Minimal and maximal value for `loc`in mf.I_in_def
    w_lux: Minimal and maximal value for `lux`in mf.I_in_def
    p_loc: period length of fluctuation in loc
    p_lux: period length of fluctuation in lux
    fluc_fun: Shape of fluctuation curve, default is sinus like
    sigma: passed on to mf.I_in_def"""
    if p_lux is None: p_lux = p_loc
    def I_in(t):
        """incoming light at time t"""
        loc_t = (fluc_fun((t%p_loc)/p_loc)*w_loc).sum(axis = 1)
        lux_t = (fluc_fun((t%p_lux)/p_lux)*w_lux).sum(axis = 1)
        return I_in_def(lux_t, loc_t, sigma)
    return I_in

def_I_ins = np.array([mf.I_in_def(40/300, 450,50), 
                      mf.I_in_def(40/300, 650,50)])

def fluc_nconst(I_ins = def_I_ins, period = 10, fluc_fun = sinus):
    """returns I_in(t), that averages over the I_ins provided
    
    I_in(t) is a weighted average over the I_ins
    
    I_ins: array of shape (n,101), different incoming light
    period: period length"""
    id_I_in, dI = np.linspace(0,period,len(I_ins)+1, retstep = True)
    id_I_in.shape = -1,1
    def I_in(t):
        """incoming light at time t"""
        # proportion of each incoming light
        prop_I = (np.abs(id_I_in-t%period)<dI)*\
                        (1-(np.abs(id_I_in-t)%period)/dI)
        prop_I[0] += prop_I[-1]
        return (prop_I[:-1, np.newaxis]*I_ins[...,np.newaxis]).sum(axis = 0).T
    return I_in