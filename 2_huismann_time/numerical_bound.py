"""
@author: J.W.Spaak

Contains functions to compute the boundary growth rate of species

Species: Method to create species and compute their boundary growth rates

`bound_growth` function to compute the boundary growth rate numerically

`equi_point` function to compute the instable equilibrium

`r_i` numerically computes the growth rate in one period

`dwdt` right hand side of the differential equation

`test_r_i_av` alternative (randomize) way to compute r_i
"""

import numpy as np
from scipy.integrate import simps,odeint
import communities_chesson as ches

class Species:
    """generates a pair of species
    
    The species are generated by the function while running
    parameter_gen should be a function to generate species
    
    Example:
        spec = Species(ches.photoinhibition_par) #create species
        spec.new_period(5) #compute the boundary growthrate of period 5
        spec.r_i #check the boundary growth rate
        
    """
    def __init__(self, parameter_gen):
        """computes the species parameters"""
        species, carbon, I_r = ches.gen_species(parameter_gen)
        self.species = species #species parameters
        self.carbon = carbon #carbonuptake functions, [carbon1(I), carbon2(I)]
        self.I_r = I_r #range of incomming light intensity
        self.P = np.array([]) #to save different period lengths
        
        spec_redo = species.copy() 
        spec_redo[:,0] = species[:,1].copy()
        spec_redo[:,1] = species[:,0].copy()
        carb_redo = [carbon[1], carbon[0]]
                     
        self._redo = [spec_redo, carb_redo] #to compute r_2
        self.comp = np.array([]) #to save competition
        self.envi = np.array([]) #to save DeltaE
        self.r_i = np.array([]) #to save boundary grwoth rates
        
    def new_period(self, P = None):
        """computes the boundary growth rate for a new period length
        
        if P is None it will be randomly generated"""
        if P is None:
            P = np.random.uniform(5,50)
        self.P = np.append(self.P,P) #append P
        
        #compute the parameters
        comp1, envi1, r_i_1 = bound_growth(self.species,self.carbon,
                                           self.I_r, self.P[-1])
        comp2, envi2, r_i_2 = bound_growth(self._redo[0], self._redo[1],
                                           self.I_r, self.P[-1])
        #store the computed parameters
        self.comp = np.append(self.comp,np.array([comp1,comp2]))
        self.envi = np.append(self.envi,np.array([envi1,envi2]))
        self.r_i = np.append(self.r_i,np.array([r_i_1, r_i_2]))
    
    def equi(self,light,i):
        """computes the equilibrium of species i at light intensity light"""
        return ches.equilibrium(light, self.species[:,i], self.carbon[i])

def bound_growth(spec, carbon,I_r ,P):
    """computes av(r_i) for species
    
    species, carbon, I_r should be outputs of gen_species
    I_r should be the range in which I_in fluctuates
    
    returns deltaC, delta E, r_i = deltaE-deltaC
    
    delta E is assumed to be very small"""
    if I_r.ndim == 1:
        I_r = np.ones((1,spec.shape[-1]))*I_r[:,np.newaxis]
    E_star, C_star = equi_point(spec, carbon, I_r)
    print(E_star.shape, C_star.shape, "equi_points")
    if (C_star <1).any():
        print("printed by bound_growth",np.amin( C_star))
    curl_C = lambda C: -r_i(C, E_star, spec, P,carbon)
    curl_E = lambda E: r_i(C_star, E, spec, P,carbon)
    
    Im, IM = I_r
    integrand_C = lambda I: curl_C(ches.equilibrium(spec, carbon, I, 'simple'))/(IM-Im)
    integrand_E = lambda I: curl_E(I)/(IM-Im)

    acc_rel_I = 11
    rel_I,dx = np.linspace(1e-10,1,acc_rel_I,retstep = True)
    rel_I = rel_I.reshape((1,-1))
    I_eff = np.expand_dims(IM-Im,-1)*rel_I+np.expand_dims(Im,-1)
    print(I_eff.shape, "I_EFF")
    simps_C = np.zeros((acc_rel_I,)+spec.shape[1:])
    simps_E = np.zeros((acc_rel_I,)+spec.shape[1:])
    print(simps_C.shape, "simps_shap")
    print(ches.equilibrium(spec, carbon, I_eff[:,0], 'simple').shape, "equi_check")
    print(I_eff[:,0].shape, E_star.shape, "check E_star, I_EFF")
    curl_E(I_eff[:,0], True)/(IM-Im)
    for i in range(acc_rel_I):
        simps_C[i] = integrand_C(I_eff[:,i])
        simps_E[i] = integrand_E(I_eff[:,i])
        #print(simps_C[i].shape, "simps_C")
        #print(simps_E[i].shape,"simpsE")
    
    ave_C = simps(simps_C, dx = dx, axis = 0)
    ave_E = simps(simps_E, dx = dx, axis = 0)
    print(ave_C.shape, ave_E.shape, "aves")
    integrand_stor = lambda I_y, I_x: integrand_C(I_x)*integrand_E(I_y)
    Im_fun = lambda x: Im
    IM_fun = lambda x: IM
    stor = 0#dblquad(integrand_stor, Im, IM, Im_fun, IM_fun)[0]
    gamma =  0#gamma_fun(lambda C,E: r_i(C,E,species, P))(C_star, E_star)
    return ave_C, ave_E,ave_E-ave_C


def equi_point(species, carbon,I_r):
    """computes the incoming light for unstable coexistence
    
    returns E_star, C_star
    
    species, carbon, I_r should be outputs of gen_species"""
    E_star = ches.find_balance(species, carbon, I_r)
    C_star = ches.equilibrium(species, carbon, E_star, 'simple')
    return E_star, C_star
    
def test_r_i(C,E, species,P,carbon):
    """computes r_i for the species[:,0] assuming species[:,1] at equilibrium
    
    does this by solving the differential equations
    C should be the density of the resident species, E the incomming light
    P the period length, carbon = [carbon[0],carbon[1]] the carbon uptake 
    functions of both species
    
    returns r_i for this period"""

    time = np.linspace(0,P,50)
    sol = odeint(dwdt, np.array([np.ones(C.shape),C]).reshape(-1), time, 
                        (species, E, carbon))
    sol = sol.reshape(50,2,2,-1)
    i = np.random.randint(sol.shape[-1])
    i = 0
    equis = sol[-1,1,:,i]
    
    print(equis, "equiiis")
    equis = ches.equilibrium(species, carbon, E)
    print(dwdt(sol[-1].reshape(-1), 0,spec,E,carbon).reshape([2,2,-1])[1], "\n")
    print(dwdt(np.array([np.ones(equis.shape), equis]).reshape(-1), 0,spec,E,carbon).reshape([2,2,-1])[1])
    plt.figure()
    res = 0
    inv = int(not res)
    equis = ches.equilibrium(species, carbon, E)[:,i]
    W_p = C[res,i]
    test = equis[res] -(equis[res]-W_p)*np.exp(-time*spec[-1,res,i])
    plt.plot(sol[:,1,res,i])
    plt.plot(test,'o')
    plt.figure()
    abso = spec[0,:,i]*equis
    print(abso, C[inv,i].shape)
    
    plt.plot(sol[:,0,inv,i])
    plt.plot(sol[:,0,res,i])
    W_I = 1*np.exp((abso[inv]/abso[res]-1)*spec[-1,inv,i]*time)\
                    *(test/W_p)**(abso[inv]/abso[res]*spec[-1,inv,i]/spec[-1,res,i])
    print(C[inv,i], test[0]==W_p, "C_inv")
    plt.figure()
    plt.plot(W_I)

def r_i(C,E, species,P,carbon):
    """computes r_i for the species[:,0] assuming species[:,1] at equilibrium
    
    does this by solving the differential equations
    C should be the density of the resident species, E the incomming light
    P the period length, carbon = [carbon[0],carbon[1]] the carbon uptake 
    functions of both species
    
    returns r_i for this period"""
    sol = odeint(dwdt, np.array([np.ones(C.shape),C]).reshape(-1), [0,P], 
                                (species, E, carbon))
    sol = sol.reshape(2,2,2,-1)
    return np.log(sol[1,:,0]/1)/P #divide by P, to compare different period length
        
def dwdt(W,t,species, I_in,carbon):
    """computes the derivative, either for one species or for two
    biomass is the densities of the two species,
    species contains their parameters
    light0 is the incomming light at this given time"""
    if W.ndim == 1:
        W = W.reshape(2,2,-1)
    k,l = species[[0,-1]]
    
    abso = k[:,None]*W # absorption coefficient
    rel_abso = np.ones(W.shape)
    res_abso = k*W[1]
    rel_abso[1,0] = W[0,0]*k[1]/(k[0]*W[1,0])
    rel_abso[0,1] = W[0,1]*k[0]/(k[1]*W[1,1])
    if np.amin(rel_abso)<0:
        print(np.amin(rel_abso), "error in absorption")
        print(np.amin(W))
        
    carb_up = lambda I: carbon(species,I,'special')/(np.expand_dims(k,-1)*I)
    def carb_up(I):
        a = carbon(species,I,'special')
        return a/(k[:,None,:,None]*I)
    # relative light, needed for integration
    rel_I,dx = np.linspace(1e-10,1,21,retstep = True)
    rel_I = rel_I.reshape((1,1,-1))
    global counter0
    
    I_out = I_in*np.exp(-res_abso) # outcoming light for species
    I_eff = np.expand_dims(I_in-I_out,-1)*rel_I+np.expand_dims(I_out,-1)
    #growth rate
    def growth(W):
        #integrate carbonuptake, integral computet with linear trans.
        return simps(carb_up(I_eff),dx = dx,axis=-1)\
                            *(I_in-I_out)
    a = l*W
    loss = a.copy()
    loss[0,0] = a[1,0]
    loss[0,1] = a[0,0]
    loss[1,0] = a[0,1]
    dwdt2 = rel_abso*growth(W)-loss
    new = dwdt2.copy()
    new[0,1] = dwdt2[1,0]
    new[1,0] = dwdt2[0,0]
    new[0,0] = dwdt2[0,1]
    return new.reshape(-1)

def test_r_i_av(species, P,carbon):
    """computes av(r_i), the average boundary_growth rate
    
    species, carbon should be the species parameters, computed by gen_species
    P is the period length
    Averaging is done by taking the outcomes of different starting C and E
    """
    r_i_val = []
    mini = ches.equilibrium(50, species[:,1],carbon[1])
    maxi = ches.equilibrium(200, species[:,1],carbon[1])
    for C in np.linspace(mini, maxi, 10):
        print(C)
        for E in np.linspace(50,200,10):
            r_i_val.append(r_i(C,E,species,P,carbon))
    return np.average(r_i_val)

counter0 = 0
spec, carb, I_r = ches.gen_species(ches.sat_carbon_par, num = 500)
print(spec.shape)
E_star, C_star = equi_point(spec, carb, I_r)
print(E_star.shape, C_star.shape, "equi_points")
P = 10
if (C_star <1).any():
    print("printed by bound_growth",np.amin( C_star))
curl_C = lambda C: test_r_i(C, E_star, spec, P,carb)
curl_E = lambda E: test_r_i(C_star, E, spec, P,carb)
acc_rel_I = 11
rel_I,dx = np.linspace(1e-10,1,acc_rel_I,retstep = True)
rel_I = rel_I.reshape((1,-1))
I_eff = np.expand_dims(200-50,-1)*rel_I+np.expand_dims(50,-1)
i = 0
integrand_C = lambda I: curl_C(ches.equilibrium(spec, carb, I, 'simple'))
integrand_E = lambda I: curl_E(I)
a = integrand_C(I_eff[:,i])
#v = integrand_E(I_eff[:,i])
#a,b,c = bound_growth(spec[:,:,:10], carb, I_r,10)
# print(np.sum(~np.isnan(c)), np.amin(c), "finla")
#plit(*c)